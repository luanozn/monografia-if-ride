\chapter{Implementação do Back-end (API REST)}

Após o levantamento e análise dos requisitos, foi inicializado o desenvolvimento do sistema, sendo feito sua construção na IDE IntelliJ Idea, utilizando a linguagem Java e o Framework Spring.

\section{Configuração Inicial}
A primeira etapa do desenvolvimento do sistema foi a criação do projeto Spring Boot, utilizando a IDE IntelliJ IDEA. Para garantir a integração de todos os componentes necessários, foram adicionadas as seguintes dependências ao arquivo pom.xml:


\begin{table}[h!]
    \centering
    \begin{tabular}{|>{\centering\arraybackslash}m{4cm}|m{10cm}|}
        \hline
        \textbf{Dependência} & \textbf{Descrição} \\ \hline
        Spring Boot Starter Data JPA & Para integração com o banco de dados e utilização do JPA para persistência de dados. \\ \hline
        Spring Boot Starter Web & Habilita o desenvolvimento de APIs RESTful no sistema. \\ \hline
        MySQL Connector & Conecta o sistema ao banco de dados MySQL em ambiente de produção. \\ \hline
        Bucket4j & Utilizado para implementar controle de limites de requisições (rate limiting) na API. \\ \hline
        Springdoc OpenAPI & Para documentação automática da API no formato OpenAPI. \\ \hline
        Ehcache & Implementação de cache para melhorar a performance do sistema. \\ \hline
        Lombok & Reduz a verbosidade do código, utilizando anotações como @Getter, @Setter, e @Builder. \\ \hline
        Spring Boot Starter AMQP & Integração com filas AMQP, como RabbitMQ, para gerenciamento de mensagens assíncronas. \\ \hline
        Spring Boot Starter Validation & Validação de dados nas requisições HTTP. \\ \hline
        Flyway & Controle de versionamento do banco de dados, realizando migrações e manutenção do esquema. \\ \hline
        Spring Security & Implementação de segurança na aplicação, incluindo autenticação e autorização via JWT. \\ \hline
        Spring Security Test & Para escrever testes de segurança e garantir que a aplicação esteja protegida. \\ \hline
    \end{tabular}
    \caption{Tabela de dependências utilizadas}
    \label{tab:dep_spring}
\end{table}

\clearpage
\newpage
\section{Projeto do Banco de Dados}
O banco de dados da aplicação de gerenciamento de \textit{tickets} foi projetado para armazenar e organizar informações essenciais sobre os chamados e suas interações. A modelagem das tabelas foi baseada nas entidades principais do sistema, como Usuário, \textit{Ticket} e Registro de Trabalho, garantindo que os relacionamentos entre elas sejam bem definidos e otimizados para consultas eficientes.

A geração das tabelas, colunas e chaves estrangeiras foi realizada automaticamente pelo Spring Data JPA, a partir das classes de entidade (POJOs) anotadas com as especificações do JPA. Essa abordagem facilita a manutenção do esquema do banco de dados, assegurando que as estruturas estejam sempre alinhadas com o modelo de domínio da aplicação.

Essa modelagem permite a escalabilidade do sistema e a integridade dos dados, garantindo que todas as operações realizadas pelos usuários sejam devidamente registradas e acessíveis conforme as permissões definidas.

\begin{figure}[!h]
    \centering
    \rotatebox{90}{ % Gira a imagem 90 graus no sentido horário
        \includegraphics[scale=0.3]{figuras/diagramas/banco de dados/diagrama de classes do banco de dadosv2.png}
    }
    \caption{Diagrama de classes do banco de dados}
    \label{fig:my_label}
\end{figure}

\newpage

\section{Estrutura de Pacotes do Back-end}

A Figura \ref{fig:pacotes} mostra a estrutura de pacotes do back-end em que se observa a estutura de pacotes geral e outras mais específicas. A Figura \ref{fig:pacotes}(a), mostra os pacotes da aplicação. A Figura \ref{fig:pacotes}(b), mostra os subpacotes do controller e model. A Figura \ref{fig:pacotes}(c), detalha sobre o subpacote de dto. Por fim, a Figura \ref{fig:pacotes}(d), detalha o subpacote de repository e service.

\begin{figure}[h]
    \begin{subfigure}{0.24\linewidth}    \includegraphics[width=1\textwidth,,height=8cm]{figuras/sistema/estrutura de pacotes backend/estrutura-pacote-backend-1.png}
    \subcaption{Estrutura geral.}
    \label{fig:pac1}
    \end{subfigure}
    \begin{subfigure}{0.24\linewidth}    \includegraphics[width=1\textwidth,height=8cm]{figuras/sistema/estrutura de pacotes backend/estrutura-pacote-backend-2.png}
    \subcaption{Estrutura subpacotes 1.}
    \label{fig:pac2}
    \end{subfigure}    
\begin{subfigure}{0.24\linewidth}    
    \includegraphics[width=1\textwidth,,height=8cm]{figuras/sistema/estrutura de pacotes backend/estrutura-pacote-backend-3.png}
    \subcaption{Estrutura subpacotes 2.}
    \label{fig:pac3}
\end{subfigure}
    \begin{subfigure}{0.24\linewidth}    
    \includegraphics[width=1\textwidth,,height=8cm]{figuras/sistema/estrutura de pacotes backend/estrutura-pacote-backend-4.png}
    \subcaption{Estrutura subpacotes 3.}
    \label{fig:pac4}
    \end{subfigure}
    \caption{Estrutura de pacotes do Back-end} \label{fig:pacotes}
    \end{figure}

\section{Endpoints da api}

Nesta seção, são apresentados os endpoints da API do sistema de gerenciamento de \textit{tickets}. A API oferece funcionalidades para autenticação, gestão de usuários, categorias, departamentos, regras de prioridade, \textit{tickets}, registros de trabalho e comentários. Abaixo estão os detalhes de cada conjunto de endpoints.

\subsection{Endpoints de Autenticação}

A autenticação é um mecanismo essencial para assegurar que apenas usuários devidamente autorizados tenham acesso aos recursos do sistema. Os principais endpoints relacionados ao processo de autenticação estão descritos na Tabela~\ref{tab:endpoints_auth}.

\begin{table}[h!]
    \centering
    \caption{Endpoints da API de Autenticação}
    \label{tab:endpoints_auth}
    \begin{tabular}{|c|c|p{8cm}|}
        \hline
        \textbf{Método} & \textbf{Endpoint} & \textbf{Descrição} \\ \hline
        POST & \texttt{/api/v1/auth/login} & Endpoint utilizado para autenticação de usuários. Recebe um JSON contendo credenciais e retorna um token JWT para acesso autenticado. \\ \hline
        POST & \texttt{/api/v1/auth/refresh} & Permite renovar o token de autenticação quando este expira, retornando um novo token JWT. \\ \hline
    \end{tabular}
\end{table}
\newpage

\subsection{Endpoints de Usuários}

Os endpoints relacionados aos usuários possibilitam a realização das operações de criação, consulta, atualização e remoção de registros no sistema. Tais funcionalidades são essenciais para o gerenciamento de acessos e o controle de permissões dentro do ambiente da aplicação, garantindo a integridade e a segurança das interações realizadas. A Tabela~\ref{tab:endpoints_usuario} apresenta os principais endpoints da API responsáveis por essas operações.


\begin{table}[h!]
    \centering
    \caption{Endpoints da API de Usuários}
    \label{tab:endpoints_usuario}
    \begin{tabular}{|c|c|p{8cm}|}
        \hline
        \textbf{Método} & \textbf{Endpoint} & \textbf{Descrição} \\ \hline
        POST & \texttt{/api/v1/usuarios} & Criação de um novo usuário no sistema. \\ \hline
        GET & \texttt{/api/v1/usuarios} & Retorna a lista de todos os usuários cadastrados. \\ \hline
        GET & \texttt{/api/v1/usuarios/\{id\}} & Retorna um usuário específico com base no ID. \\ \hline
        PUT & \texttt{/api/v1/usuarios/\{id\}} & Atualiza as informações de um usuário específico. \\ \hline
        DELETE & \texttt{/api/v1/usuarios/\{id\}} & Remove um usuário do sistema com base no ID. \\ \hline
    \end{tabular}
\end{table}

\subsection{Endpoints de Categorias}

A gestão de categorias desempenha um papel fundamental na organização dos \textit{tickets}, permitindo que sejam classificados em grupos específicos. Essa classificação contribui para uma melhor estruturação, priorização e tratamento das solicitações. Os principais endpoints responsáveis pelas operações de criação, consulta, atualização e remoção de categorias estão descritos na Tabela~\ref{tab:endpoints_categoria}.


\begin{table}[h!]
    \centering
    \caption{Endpoints da API de Categorias}
    \label{tab:endpoints_categoria}
    \begin{tabular}{|c|c|p{8cm}|}
        \hline
        \textbf{Método} & \textbf{Endpoint} & \textbf{Descrição} \\ \hline
        POST & \texttt{/api/v1/categorias} & Criação de uma nova categoria no sistema. \\ \hline
        GET & \texttt{/api/v1/categorias} & Retorna a lista de todas as categorias cadastradas. \\ \hline
        GET & \texttt{/api/v1/categorias/\{id\}} & Retorna uma categoria específica com base no ID. \\ \hline
        PUT & \texttt{/api/v1/categorias/\{id\}} & Atualiza as informações de uma categoria específica. \\ \hline
        DELETE & \texttt{/api/v1/categorias/\{id\}} & Remove uma categoria do sistema com base no ID. \\ \hline
    \end{tabular}
\end{table}
\newpage

\subsection{Endpoints de Departamentos}

Os departamentos são utilizados para organizar os \textit{tickets} com base nas áreas ou equipes responsáveis, contribuindo para uma melhor distribuição das demandas e agilidade no atendimento. A Tabela~\ref{tab:endpoints_departamento} apresenta os principais endpoints da API responsáveis pela gestão dos departamentos no sistema.


\begin{table}[h!]
    \centering
    \caption{Endpoints da API de Departamentos}
    \label{tab:endpoints_departamento}
    \begin{tabular}{|c|c|p{7cm}|}
        \hline
        \textbf{Método} & \textbf{Endpoint} & \textbf{Descrição} \\ \hline
        POST & \texttt{/api/v1/departamentos} & Criação de um novo departamento no sistema. \\ \hline
        GET & \texttt{/api/v1/departamentos} & Retorna a lista de todos os departamentos cadastrados. \\ \hline
        GET & \texttt{/api/v1/departamentos/\{id\}} & Retorna um departamento específico com base no ID. \\ \hline
        PUT & \texttt{/api/v1/departamentos/\{id\}} & Atualiza as informações de um departamento específico. \\ \hline
        DELETE & \texttt{/api/v1/departamentos/\{id\}} & Remove um departamento do sistema com base no ID. \\ \hline
    \end{tabular}
\end{table}

\subsection{Endpoints de Regras de Prioridade}

As regras de prioridade são utilizadas para definir o nível de urgência no tratamento dos \textit{tickets}, permitindo que o sistema atribua diferentes graus de atenção conforme critérios previamente estabelecidos. A Tabela~\ref{tab:endpoints_regra_prioridade} apresenta os principais endpoints da API responsáveis pela gestão dessas regras.


\begin{table}[h!]
    \centering
    \caption{Endpoints da API de Regras de Prioridade}
    \label{tab:endpoints_regra_prioridade}
    \begin{tabular}{|c|c|p{6.5cm}|}
        \hline
        \textbf{Método} & \textbf{Endpoint} & \textbf{Descrição} \\ \hline
        POST & \texttt{/api/v1/regraPrioridades} & Criação de uma nova regra de prioridade no sistema. \\ \hline
        GET & \texttt{/api/v1/regraPrioridades} & Retorna a lista de todas as regras de prioridade cadastradas. \\ \hline
        PUT & \texttt{/api/v1/regraPrioridades/\{id\}} & Atualiza as informações de uma regra de prioridade específica com base no ID. \\ \hline
        DELETE & \texttt{/api/v1/regraPrioridades/\{id\}} & Remove uma regra de prioridade do sistema com base no ID. \\ \hline
    \end{tabular}
\end{table}

\newpage
\subsection{Endpoints de \textit{Tickets}}

Os \textit{tickets} representam os problemas, dúvidas ou solicitações registradas pelos usuários e que demandam algum tipo de resolução por parte da equipe responsável. Eles constituem o elemento central do sistema de atendimento, permitindo o acompanhamento de todo o ciclo de vida de uma demanda. A Tabela~\ref{tab:endpoints_ticket} apresenta os principais endpoints da API utilizados na gestão dos \textit{tickets}, incluindo funcionalidades de criação, consulta, atualização e remoção.


\begin{table}[h!]
    \centering
    \caption{Endpoints da API de \textit{Tickets}}
    \label{tab:endpoints_ticket}
    \begin{tabular}{|c|c|p{8cm}|}
        \hline
        \textbf{Método} & \textbf{Endpoint} & \textbf{Descrição} \\ \hline
        POST & \texttt{/api/v1/tickets} & Criação de um novo \textit{ticket} no sistema. \\ \hline
        GET & \texttt{/api/v1/tickets} & Retorna a lista de todos os \textit{tickets} com filtros opcionais (titulo, status, prioridade, responsável, data de início e data de fim). \\ \hline
        GET & \texttt{/api/v1/tickets/\{id\}} & Retorna os detalhes de um \textit{ticket} específico com base no ID. \\ \hline
        PUT & \texttt{/api/v1/tickets/\{id\}} & Atualiza as informações de um \textit{ticket} específico com base no ID. \\ \hline
        DELETE & \texttt{/api/v1/tickets/\{id\}} & Remove um \textit{ticket} do sistema com base no ID. \\ \hline
    \end{tabular}
\end{table}

\subsection{Endpoints de Registros de Trabalho}

Os registros de trabalho estão diretamente vinculados ao acompanhamento do progresso na resolução dos \textit{tickets}, permitindo que sejam documentadas as ações executadas ao longo do atendimento. Esses registros contribuem para a rastreabilidade, análise de desempenho e melhoria contínua dos processos de suporte. A Tabela~\ref{tab:endpoints_registro_trabalho} apresenta os principais endpoints da API utilizados na gestão dos registros de trabalho.


\begin{table}[h!]
    \centering
    \caption{Endpoints da API de Registros de Trabalho}
    \label{tab:endpoints_registro_trabalho}
    \begin{tabular}{|c|c|p{6.5cm}|}
        \hline
        \textbf{Método} & \textbf{Endpoint} & \textbf{Descrição} \\ \hline
        POST & \texttt{/api/v1/registroTrabalho} & Criação de um novo registro de trabalho associado a um \textit{ticket}. \\ \hline
        GET & \texttt{/api/v1/registroTrabalho} & Retorna todos os registros de trabalho associados a um \textit{ticket} específico. \\ \hline
        PUT & \texttt{/api/v1/registroTrabalho/\{id\}} & Atualiza um registro de trabalho específico com base no ID fornecido. \\ \hline
        DELETE & \texttt{/api/v1/registroTrabalho/\{id\}} & Remove um registro de trabalho específico com base no ID fornecido. \\ \hline
    \end{tabular}
\end{table}

\subsection{Endpoints de Comentários}

Os comentários são utilizados para registrar observações, atualizações ou interações realizadas durante o ciclo de vida de um \textit{ticket}, contribuindo para a comunicação entre os envolvidos no atendimento. Eles também podem conter anexos, como imagens ou documentos que auxiliem na resolução da demanda. A Tabela~\ref{tab:endpoints_comentarios} apresenta os principais endpoints da API responsáveis pela gestão dos comentários no sistema.


\begin{table}[h!]
    \centering
    \caption{Endpoints da API de Comentários}
    \label{tab:endpoints_comentarios}
    \begin{tabular}{|c|c|p{6.5cm}|}
        \hline
        \textbf{Método} & \textbf{Endpoint} & \textbf{Descrição} \\ \hline
        POST & \texttt{/api/v1/comentarios} & Criação de um novo comentário associado a um \textit{ticket}, com possibilidade de incluir anexo. \\ \hline
        GET & \texttt{/api/v1/comentarios} & Retorna todos os comentários associados a um \textit{ticket} específico. \\ \hline
        PUT & \texttt{/api/v1/comentarios/\{id\}} & Atualiza um comentário específico com base no ID fornecido. \\ \hline
        DELETE & \texttt{/api/v1/comentarios/\{id\}} & Remove um comentário específico com base no ID fornecido. \\ \hline
        DELETE & \texttt{/api/v1/comentarios/\{id\}/anexo} & Deleta um anexo de um comentário especificado pelo ID e nome do arquivo. \\ \hline
    \end{tabular}
\end{table}

\section{Trechos de Código}

O sistema possui diversas regras de negócio que garantem o correto funcionamento das operações. A seguir, são apresentados trechos de código que exemplificam algumas dessas regras, aplicadas em diferentes funcionalidades, como cadastro, atualização, exclusão e consulta de dados

\subsection{Usuário}

O Listing  \ref{fig:codUsuario} apresenta a implementação das regras de negócio para a criação e consulta de usuários. No primeiro trecho de código, o método criar recebe um objeto UsuarioRequestDTO, converte os dados para a entidade Usuario e valida a existência de e-mail e CPF antes de persistir no banco de dados. Caso já exista um usuário com os mesmos dados, a operação é interrompida com uma resposta de erro. Se os dados forem válidos, a senha do usuário é criptografada e o registro é salvo, seguido do envio de um e-mail de confirmação.

No segundo trecho, o método buscaPorId verifica a identidade e as permissões do usuário autenticado antes de permitir o acesso aos dados de um usuário específico. Se um cliente tentar acessar informações de outro usuário, a requisição é negada. Caso contrário, o usuário é recuperado do banco de dados e retornado como um UsuarioResponseDTO.


\begin{lstlisting}[language=Java, caption={Regras do Usuário da API}, label={fig:codUsuario}]
@Service
public class UsuarioServiceImpl implements UsuarioService, UserDetailsService {

    @Override
    public ResponseEntity<MessageResponseDTO> criar(UsuarioRequestDTO usuarioCreate) {
        Usuario usuario = mapper.mapTo(usuarioCreate, Usuario.class);
        usuario.setContatos(mapper.toList(usuarioCreate.getContatos(), Telefone.class));
        usuario.setTipoUsuario(UsuarioRole.CLIENTE);
        usuario.getContatos().forEach(telefone -> telefone.setUsuario(usuario));

        boolean emailExists = usuarioRepository.existsByEmail(usuarioCreate.getEmail().toLowerCase());
        boolean cpfExists = usuarioRepository.existsByCpf(usuarioCreate.getCpf().trim());

        if(emailExists || cpfExists) {
            String errorMessage = "Usuario ja cadastrado. Campo duplicado: ";
            errorMessage += emailExists ? "Email" : "CPF";
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(MessageResponseDTO
                    .builder()
                    .code(400)
                    .status("Bad Request")
                    .message(errorMessage)
                    .build());
        }

        String encryptedPassword = new BCryptPasswordEncoder().encode(usuario.getSenha());
        usuario.setSenha(encryptedPassword);

        var usuarioSalvo = usuarioRepository.save(usuario);

        emailService.enviarUsuarioCadastradoEmail(usuarioSalvo);
        return ResponseEntity.status(HttpStatus.CREATED).body(MessageResponseDTO
                .builder()
                .code(201)
                .status("Created")
                .message("Usuario criado com sucesso.")
                .build());
    }

    @Override
    public UsuarioResponseDTO buscaPorId(Long uuid) {
        Long uuidAuth = Long.valueOf((String) SecurityContextHolder.getContext().getAuthentication().getPrincipal());

        boolean somenteCliente = SecurityContextHolder.getContext().getAuthentication()
                .getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .allMatch(role -> role.equals("ROLE_CLIENTE"));

        if(somenteCliente && !Objects.equals(uuidAuth, uuid))
            throw new CustomAccessDeniedException("Acesso negado.Voce nao tem permissao para acessar este recurso.");

        Usuario usuario = usuarioRepository.findById(uuid)
                .orElseThrow(() -> new ResourceNotFoundException("Nao foi encontrado nenhum usuario com esse id."));
        return mapper.mapTo(usuario, UsuarioResponseDTO.class);
    }
}
\end{lstlisting}

\subsection{Regra Prioridade}

O Listing \ref{fig:codRegraPrioridade} apresenta a implementação das regras de negócio para a criação de regras de prioridade no sistema. O método criar recebe um objeto RegraPrioridadeRequestDTO e o converte para a entidade RegraPrioridade. Em seguida, busca a categoria e o departamento associados à regra, garantindo que ambos existam antes de prosseguir com a persistência dos dados.

Além disso, a anotação @CacheEvict é utilizada para limpar o cache de regras de prioridade sempre que uma nova regra for criada, garantindo que os dados armazenados estejam sempre atualizados. Por fim, a regra de prioridade é salva no banco de dados e retornada como um RegraPrioridadeResponseDTO.

\begin{lstlisting}[language=Java, caption={Regras de Prioridade}, label={fig:codRegraPrioridade}]
@Service
public class RegraPrioridadeServiceImpl implements RegraPrioridadeService {

    @Override
    @CacheEvict(value = "regraPrioridadeCache", allEntries = true)
    public RegraPrioridadeResponseDTO criar(RegraPrioridadeRequestDTO regraPrioridadeRequestDTO) {
        RegraPrioridade regraPrioridade = mapper.mapTo(regraPrioridadeRequestDTO, RegraPrioridade.class);
        Categoria categoria = categoriaService.buscaPorId(regraPrioridade.getCategoria().getId());
        Departamento departamento = mapper.mapTo(departamentoService.buscarPorId(regraPrioridade.getDepartamento().getId()),Departamento.class);
        regraPrioridade.setCategoria(categoria);
        regraPrioridade.setDepartamento(departamento);
        return mapper.mapTo(regraPrioridadeRepository.save(regraPrioridade), RegraPrioridadeResponseDTO.class);
    }
}
\end{lstlisting}

\newpage

\subsection{Departamento}

O Listing \ref{fig:codDepartamento} apresenta a implementação das regras de negócio para a criação de um departamento no sistema. O método criar recebe um objeto DepartamentoRequestDTO e o converte para a entidade Departamento.

Antes de persistir os dados, o sistema valida se o usuário informado como gerente realmente possui esse cargo. Para isso, busca os detalhes do usuário pelo ID e verifica se ele é um gerente. Caso contrário, uma exceção ResourceNotFoundException é lançada, impedindo o cadastro com informações inválidas.

Após essa validação, o usuário é associado ao departamento, e a entidade é salva no banco de dados, retornando um DepartamentoResponseDTO.

\begin{lstlisting}[language=Java, caption={Departamento}, label={fig:codDepartamento}]
@Service
public class DepartamentoServiceImpl implements DepartamentoService {
    
    @Override
    @CacheEvict(value = "departamentoCache", allEntries = true)
    public DepartamentoResponseDTO criar(DepartamentoRequestDTO departamentoRequestDTO) {
        Departamento departamento = mapper.mapTo(departamentoRequestDTO, Departamento.class);
        UsuarioResponseDTO usuarioResponseDTO = usuarioService.buscaPorId(departamento.getGerente().getId());
        if(usuarioService.verificarSeUsuarioEhGerente(usuarioResponseDTO.getId()))
            throw new ResourceNotFoundException("Usuario enviado nao e um gerente.");

        Usuario usuario = mapper.mapTo(usuarioResponseDTO,Usuario.class);
        departamento.setGerente(usuario);
        return mapper.mapTo(departamentoRepository.save(departamento), DepartamentoResponseDTO.class);
    }
}
\end{lstlisting}

\newpage

\subsection{\textit{Ticket}}

O Listing \ref{fig:codTicket} apresenta a implementação do serviço responsável pelo gerenciamento de \textit{tickets} no sistema. A classe TicketServiceImpl contém métodos para criação, busca, atualização e remoção de \textit{tickets}, além de funcionalidades como envio de e-mails e geração de relatórios em CSV.

O método criar recebe um TicketRequestDTO e realiza diversas operações antes de persistir o \textit{ticket} no banco de dados. Primeiro, busca e valida as entidades associadas, como Categoria, Departamento e RegraPrioridade. Em seguida, identifica o cliente e o responsável pelo \textit{ticket}, atribui a prioridade com base nas regras definidas e calcula a data máxima para resolução. Após salvar a entidade, um e-mail de notificação é enviado.

O serviço também implementa filtros para listar \textit{tickets} conforme o perfil do usuário, garantindo que clientes, funcionários e gerentes vejam apenas os chamados pertinentes ao seu papel. Além disso, o método atualizar registra um histórico de alterações nos campos modificados, preservando um log das mudanças realizadas.

Por fim, a classe contém métodos para alterar o status de um \textit{ticket} para "Em Andamento" e remover \textit{tickets}.

\begin{lstlisting}[language=Java, caption={Ticket}, label={fig:codTicket}]
@Service
public class TicketServiceImpl implements TicketService {

    @Override
    public TicketResponseDTO criar(TicketRequestDTO ticketRequestDTO) {
        Ticket ticket = mapper.mapTo(ticketRequestDTO, Ticket.class);
        Categoria categoria = categoriaService.buscaPorId(ticket.getCategoria().getId());
        Departamento departamento = mapper.mapTo(departamentoService.buscarPorId(ticket.getDepartamento().getId()),Departamento.class);
        RegraPrioridade regraPrioridade = regraPrioridadeService.buscarPorCategoriaAndDepartamento(categoria,departamento);

        Usuario cliente;

        if(ticket.getCliente() == null || ticket.getCliente().getId() == null){
            Long uuidAuth = Long.valueOf((String) SecurityContextHolder.getContext().getAuthentication().getPrincipal());
            cliente = mapper.mapTo(usuarioService.buscaPorId(uuidAuth),Usuario.class);
        } else
            cliente = mapper.mapTo(usuarioService.buscaPorId(ticket.getCliente().getId()),Usuario.class);

        Usuario responsavel;

        if(ticket.getResponsavel() == null || ticket.getResponsavel().getId() == null)
            responsavel = departamento.getGerente();
        else
            responsavel = ticket.getResponsavel();

        ticket.setCliente(cliente);
        ticket.setResponsavel(responsavel);
        ticket.setDataCriacao(LocalDateTime.now());
        ticket.setStatus(StatusTicket.ABERTO);
        ticket.setCategoria(categoria);
        ticket.setDepartamento(departamento);
        ticket.setPrioridade(regraPrioridade.getPrioridade());
        ticket.setDataMaximaResolucao(ticket.getDataCriacao().plusHours(regraPrioridade.getHorasResolucao()));
        ticket = ticketRepository.save(ticket);
        emailService.enviarTicketEmail(ticket);
        return mapper.mapTo(ticket, TicketResponseDTO.class);
    }

    @Override
    public List<TicketSimpleResponseDTO> buscarTodos() {
        List<Ticket> ticketList = ticketRepository.findAll();

        return mapper.toList(ticketList, TicketSimpleResponseDTO.class);
    }

    private Set<String> getUserRoles(Authentication authentication) {
        return authentication.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.toSet());
    }

    @Override
    public List<TicketSimpleResponseDTO> buscarTodosFilter(String titulo, StatusTicket status, Prioridade prioridade, String nomeResponsavel, String dataInicio, String dataFim) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        Long uuidAuth = Long.valueOf((String) authentication.getPrincipal());
        Set<String> roles = getUserRoles(authentication);

        Specification<Ticket> spec = TicketSpecification.filterTickets(titulo, status, prioridade, nomeResponsavel,dataInicio,dataFim);

        List<Ticket> ticketList = ticketRepository.findAll(spec);

        if (roles.contains("ROLE_CLIENTE")) {
            ticketList = ticketList.stream()
                    .filter(ticket -> Objects.nonNull(ticket.getCliente()) && Objects.equals(ticket.getCliente().getId(), uuidAuth))
                    .toList();
        } else if (roles.contains("ROLE_FUNCIONARIO")) {
            ticketList = ticketList.stream()
                    .filter(ticket -> Objects.nonNull(ticket.getResponsavel()) && Objects.equals(ticket.getResponsavel().getId(), uuidAuth))
                    .toList();
        } else if (roles.contains("ROLE_GERENTE")) {
            ticketList = ticketList.stream()
                    .filter(ticket -> Objects.nonNull(ticket.getDepartamento()) && Objects.equals(ticket.getDepartamento().getGerente().getId(), uuidAuth))
                    .toList();
        }

        return mapper.toList(ticketList, TicketSimpleResponseDTO.class);
    }

    @Override
    public TicketResponseDTO buscarPorId(Long id) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        Long uuidAuth = Long.valueOf((String) authentication.getPrincipal());
        Set<String> roles = getUserRoles(authentication);

        Optional<Ticket> ticketOptional;
        if (roles.contains("ROLE_CLIENTE")) {
            ticketOptional = ticketRepository.findByClienteIdAndId(uuidAuth,id);
        } else if (roles.contains("ROLE_FUNCIONARIO")) {
            ticketOptional = ticketRepository.findByResponsavelIdAndId(uuidAuth,id);
        } else if (roles.contains("ROLE_GERENTE")) {
            ticketOptional = ticketRepository.findByDepartamentoGerenteIdAndId(uuidAuth,id);
        } else
            ticketOptional = ticketRepository.findById(id);

        Ticket ticket = ticketOptional.orElseThrow(() ->
                new ResourceNotFoundException("Nao foi encontrado nenhum ticket com esse id.")
        );

        return mapper.mapTo(ticket, TicketResponseDTO.class);
    }

    @Override
    public TicketResponseDTO atualizar(Long id, TicketRequestUpdateDTO ticketRequestUpdateDTO) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        Long uuidAuth = Long.valueOf((String) authentication.getPrincipal());
        Set<String> roles = getUserRoles(authentication);

        Optional<Ticket> ticketOptional;
        if (roles.contains("ROLE_CLIENTE")) {
            ticketOptional = ticketRepository.findByClienteIdAndId(uuidAuth,id);
        } else if (roles.contains("ROLE_FUNCIONARIO")) {
            ticketOptional = ticketRepository.findByResponsavelIdAndId(uuidAuth,id);
        } else if (roles.contains("ROLE_GERENTE")) {
            ticketOptional = ticketRepository.findByDepartamentoGerenteIdAndId(uuidAuth,id);
        } else
            ticketOptional = ticketRepository.findById(id);

        Ticket ticket = ticketOptional.orElseThrow(() ->
                new ResourceNotFoundException("Nao foi encontrado nenhum ticket com esse id.")
        );

        Map<String, Map<String, Object>> camposAlterados = new HashMap<>();

        checkAndRecordEntityChange("categoria", ticket.getCategoria(), ticketRequestUpdateDTO.getCategoria(), camposAlterados);
        checkAndRecordEntityChange("departamento", ticket.getDepartamento(), ticketRequestUpdateDTO.getDepartamento(), camposAlterados);
        checkAndRecordEntityChange("responsavel", ticket.getResponsavel(), ticketRequestUpdateDTO.getResponsavel(), camposAlterados);
        List<String> variaveisIgnoradas = Arrays.asList("comentarios", "id", "categoria", "departamento", "responsavel", "cliente", "class", "historicos", "registroTrabalhos");
        BeanWrapper wrapper = new BeanWrapperImpl(ticket);
        for (PropertyDescriptor descriptor : wrapper.getPropertyDescriptors()) {
            String nomeVariavel = descriptor.getName();
            if (!variaveisIgnoradas.contains(nomeVariavel)) {
                Object antigoValor = wrapper.getPropertyValue(nomeVariavel);
                Object novoValor = new BeanWrapperImpl(ticketRequestUpdateDTO).getPropertyValue(nomeVariavel);

                if (novoValor != null && !novoValor.equals(antigoValor)) {
                    Map<String, Object> values = new HashMap<>();
                    values.put("antigoValor", antigoValor);
                    values.put("novoValor", novoValor);
                    camposAlterados.put(nomeVariavel, values);
                }
            }
        }

        Usuario usuarioResponsavelPelaAtualizacao = mapper.mapTo(usuarioService.buscaPorId(uuidAuth), Usuario.class);

        List<TicketHistorico> ticketHistoricoList = new ArrayList<>();
        camposAlterados.forEach((campo, valores) -> {
                    Object antigoValor = valores.get("antigoValor");
                    Object novoValor = valores.get("novoValor");
                    TicketHistorico ticketHistorico = new TicketHistorico();
                    ticketHistorico.setCampo(campo);
                    ticketHistorico.setUltimoValor(antigoValor.toString());
                    ticketHistorico.setNovoValor(novoValor.toString());
                    ticketHistorico.setDataAlteracao(LocalDateTime.now());
                    ticketHistorico.setTicket(ticket);
                    ticketHistorico.setAgente(usuarioResponsavelPelaAtualizacao);
                    ticketHistoricoList.add(ticketHistorico);
                }
        );
        ticket.getHistoricos().addAll(ticketHistoricoList);
        ticketHistoricoList.forEach(ticketHistorico -> ticketHistoricoService.criar(ticketHistorico));

        BeanUtils.copyProperties(ticketRequestUpdateDTO, ticket, objectUtils.getNullPropertyNames(ticketRequestUpdateDTO));

        var ticketSalvado = ticketRepository.save(ticket);

        if(ticketSalvado.getStatus() == StatusTicket.FINALIZADO)
            emailService.enviarTicketFinalizadoEmail(ticketSalvado);

        return mapper.mapTo(ticketSalvado, TicketResponseDTO.class);
    }

    @Override
    public Ticket atualizaTicketEmAndamento(Usuario usuario, Ticket ticket){
        String valorAntigo = ticket.getStatus().toString();
        ticket.setStatus(StatusTicket.EM_ANDAMENTO);

        List<TicketHistorico> ticketHistoricoList = new ArrayList<>();
        TicketHistorico ticketHistorico = new TicketHistorico();
        ticketHistorico.setCampo("status");
        ticketHistorico.setUltimoValor(valorAntigo);
        ticketHistorico.setNovoValor(ticket.getStatus().toString());
        ticketHistorico.setDataAlteracao(LocalDateTime.now());
        ticketHistorico.setTicket(ticket);
        ticketHistorico.setAgente(usuario);
        ticketHistoricoList.add(ticketHistorico);

        ticket.getHistoricos().addAll(ticketHistoricoList);
        ticketHistoricoList.forEach(ticketHistoricoCriar -> ticketHistoricoService.criar(ticketHistoricoCriar));

        emailService.enviarTicketEmAndamentoEmail(ticket);

        return ticketRepository.save(ticket);
    }

    private <T> void checkAndRecordEntityChange(String fieldName, T currentEntity, T newEntity, Map<String, Map<String, Object>> alteredFields) {
        Long currentId = getEntityId(currentEntity);
        Long newId = getEntityId(newEntity);

        if (!Objects.equals(currentId, newId)) {
            Map<String, Object> values = new HashMap<>();
            values.put("antigoValor", currentId);
            values.put("novoValor", newId);
            alteredFields.put(fieldName, values);
        }
    }

    private Long getEntityId(Object entity) {
        if (entity == null) return null;
        try {
            Method getIdMethod = entity.getClass().getMethod("getId");
            return (Long) getIdMethod.invoke(entity);
        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
            throw new RuntimeException("Erro ao obter o ID da entidade", e);
        }
    }

    @Override
    public void deletePorId(Long id) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        Long uuidAuth = Long.valueOf((String) authentication.getPrincipal());
        Set<String> roles = getUserRoles(authentication);

        Optional<Ticket> ticketOptional;
        if (roles.contains("ROLE_CLIENTE")) {
            ticketOptional = ticketRepository.findByClienteIdAndId(uuidAuth,id);
        } else if (roles.contains("ROLE_FUNCIONARIO")) {
            ticketOptional = ticketRepository.findByResponsavelIdAndId(uuidAuth,id);
        } else if (roles.contains("ROLE_GERENTE")) {
            ticketOptional = ticketRepository.findByDepartamentoGerenteIdAndId(uuidAuth,id);
        } else
            ticketOptional = ticketRepository.findById(id);

        if(ticketOptional.isPresent())
            ticketRepository.deleteById(id);
    }
}

\end{lstlisting}

\newpage

\subsection{Registro de Trabalho}

O Listing \ref{fig:codRegistroTrabalho} apresenta a implementação do serviço responsável pelo gerenciamento dos registros de trabalho no sistema. A classe RegistroTrabalhoServiceImpl contém métodos para criação, busca, atualização e remoção desses registros, garantindo o vínculo com \textit{tickets} e usuários do sistema.

O método criar recebe um RegistroTrabalhoRequestDTO e associa o registro a um \textit{ticket} específico e ao usuário autenticado. Caso o \textit{ticket} ainda esteja no status "Aberto", ele é atualizado para "Em Andamento" após a criação do registro.

O serviço também permite a busca de todos os registros de trabalho relacionados a um \textit{ticket} por meio do método buscarTodosPorTicket, retornando uma lista de registros vinculados ao chamado.

A funcionalidade de atualização (atualizar) permite modificar um registro existente, garantindo que apenas os campos não nulos sejam alterados, enquanto o método deletarPorId possibilita a remoção de registros de trabalho pelo seu identificador.

Essa implementação garante a rastreabilidade das atividades realizadas em cada \textit{ticket}, auxiliando no controle e na gestão dos chamados dentro do sistema.

\begin{lstlisting}[language=Java, caption={Registro de Trabalho}, label={fig:codRegistroTrabalho}]
public class RegistroTrabalhoServiceImpl implements RegistroTrabalhoService {
    @Override
    public RegistroTrabalhoReponseDTO criar(Long ticketId, RegistroTrabalhoRequestDTO registroTrabalhoRequestDTO) {
        Ticket ticket = mapper.mapTo(ticketService.buscarPorId(ticketId), Ticket.class);
        Long uuidAuth = Long.valueOf((String) SecurityContextHolder.getContext().getAuthentication().getPrincipal());
        Usuario usuario = mapper.mapTo(usuarioService.buscaPorId(uuidAuth), Usuario.class);

        RegistroTrabalho registroTrabalho = mapper.mapTo(registroTrabalhoRequestDTO,RegistroTrabalho.class);
        registroTrabalho.setTicket(ticket);
        registroTrabalho.setAgente(usuario);

        var registro = mapper.mapTo(registroTrabalhoRepository.save(registroTrabalho), RegistroTrabalhoReponseDTO.class);

        if(ticket.getStatus() == StatusTicket.ABERTO && registro.getId() != null)
            ticket = ticketService.atualizaTicketEmAndamento(usuario,ticket);

        registro.setTicket(mapper.mapTo(ticket, TicketSimpleResponseDTO.class));

        return registro;
    }

    @Override
    public List<RegistroTrabalhoReponseDTO> buscarTodosPorTicket(Long ticketId) {
        return mapper.toList(registroTrabalhoRepository.findByTicketId(ticketId), RegistroTrabalhoReponseDTO.class);
    }

    @Override
    public RegistroTrabalhoReponseDTO atualizar(Long registroId, RegistroTrabalhoRequestUpdateDTO registroTrabalhoRequestUpdateDTO) {
        RegistroTrabalho registroTrabalho = registroTrabalhoRepository.findById(registroId)
                .orElseThrow(() -> new ResourceNotFoundException("Nao foi encontrado nenhum registro com esse id."));
        BeanUtils.copyProperties(registroTrabalhoRequestUpdateDTO,registroTrabalho,objectUtils.getNullPropertyNames(registroTrabalhoRequestUpdateDTO));
        return mapper.mapTo(registroTrabalhoRepository.save(registroTrabalho), RegistroTrabalhoReponseDTO.class);
    }

    @Override
    public void deletarPorId(Long registroId) {
        registroTrabalhoRepository.deleteById(registroId);
    }
}

\end{lstlisting}

\section{Documentação Swagger do sistema}

A documentação da API é um componente essencial para garantir a compreensibilidade, reutilização e manutenção do sistema. No desenvolvimento do sistema proposto, foi utilizada a biblioteca Swagger (atualmente mantida como OpenAPI) para geração automática da documentação da API REST.

O Swagger permite descrever, de forma padronizada, todos os endpoints disponíveis, bem como os métodos HTTP suportados, parâmetros esperados, códigos de resposta e exemplos de requisições e respostas. A documentação gerada é interativa e pode ser acessada via navegador, permitindo testes diretos nos endpoints, o que facilita o trabalho de desenvolvedores e testadores.

A seguir, a Figura \ref{fig:swagger_apresentacao_1} e a Figura \ref{fig:swagger_apresentacao_2} apresenta um exemplo da interface Swagger gerada automaticamente:

\begin{figure}[h]
    \centering
        \includegraphics[width=\linewidth]{figuras/sistema/documentacao/Swagger-apresentacao-1.png}
    \caption{Visualização geral da interface do Swagger}
    \label{fig:swagger_apresentacao_1}
\end{figure}

\begin{figure}[h]
    \centering
        \includegraphics[height=6.5cm, width=\linewidth]{figuras/sistema/documentacao/Swagger-apresentacao-2.png}
    \caption{Endpoints disponíveis na Api}
    \label{fig:swagger_apresentacao_2}
\end{figure}

\newpage

Já a Figura \ref{fig:swagger_autenticacao_request} apresenta uma requisição de login realizada diretamente pela interface do Swagger, exibindo o corpo (\textit{body}) enviado com as credenciais do usuário e a Figura \ref{fig:swagger_autenticacao_response} apresenta a resposta retornada pela API. Nesse caso, ao informar corretamente o e-mail e a senha, a aplicação retorna um token JWT, que poderá ser utilizado para autenticar as próximas requisições em rotas protegidas.

\begin{figure}[h]
    \centering
        \includegraphics[width=\linewidth]{figuras/sistema/documentacao/Swagger-autenticacao-request.png}
    \caption{Requisição de login}
    \label{fig:swagger_autenticacao_request}
\end{figure}

\begin{figure}[h]
    \centering
        \includegraphics[width=\linewidth]{figuras/sistema/documentacao/Swagger-autenticacao-response.png}
    \caption{Resposta da requisição de login}
    \label{fig:swagger_autenticacao_response}
\end{figure}

\newpage






